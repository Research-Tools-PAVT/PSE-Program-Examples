# -*- coding: utf-8 -*-

import z3
import os
import sys

# https://z3prover.github.io/api/html/classz3py_1_1_rat_num_ref.html#a1012d6314d35530c58f9c018269ec867
def num(r):
    """
    Convert from Z3 to python float values.
    """
    return float(r.numerator_as_long()) / float(r.denominator_as_long())


def get_value(r):
    """
    Convert from Z3 to python values.
    """
    if z3.is_int_value(r):
        return r.as_long()
    elif z3.is_algebraic_value(r):
        return round(num(r.approx(15)), 10)
    elif z3.is_rational_value(r):
        return r.as_decimal(20)
    elif r is None:
        None
    else:
        return num(r)


"""
Below are a list of constraints that dictate which 
path is taken during actual program execution. 
We process KLEE constraints and simplify them to get these 
constraints. 
"""

# ==== Will be Autogenerated by PyKLEE ====

# candidatePaths = 5  # Top "k" paths.
# n_iters = 10  # "n" bernoulli trails (independent fair coin flips)

# choice_sym_vars = [
#     [z3.Real(f"choice_{i}_{k}") for i in range(n_iters)] for k in range(candidatePaths)
# ]
# d_sym_vars = [
#     [z3.Real(f"d_{i}_{k}") for i in range(n_iters)] for k in range(candidatePaths)
# ]
# path_prob_sym_vars = [z3.Int(f"path_prob_{i}") for i in range(candidatePaths)]
# probability_vars = [z3.Real(f"path_prob_{k}") for k in range(candidatePaths)]
# expected_heads = [z3.Real(f"sum_d_heads_{k}") for k in range(candidatePaths)]

# for k in range(candidatePaths):
#     choice_probs = 1
#     for i in range(n_iters):
#         choice_sym_vars[k][i] = z3.If(
#             d_sym_vars[k][i] == 1, probability_vars[k], 1 - probability_vars[k]
#         )
#         choice_probs = choice_probs * choice_sym_vars[k][i]
#         sum_heads = sum_heads + d_sym_vars[k][i]
#     path_prob_sym_vars[k] = choice_probs

# ==== Will be Autogenerated by PyKLEE ====


# pwd = os.path.dirname(__file__)
# if not os.path.isdir(os.path.join(pwd, "inputs")):
#     os.mkdir(os.path.join(pwd, "inputs"))

# inputFilePath = os.path.join(pwd, "inputs")


def generateCandidates(k: int, n: int):

    # optpath.set("timeout", 7500)

    z3.set_option(
        precision=15,
        rational_to_decimal=True,
        max_args=10000000,
        max_lines=1000000,
        max_depth=10000000,
        max_visited=1000000,
    )

    candidatePaths = k  # Top "k" paths.
    n_iters = n  # "n" bernoulli trails (independent fair coin flips)

    choice_sym_vars = [
        [z3.Real(f"choice_{i}_{k}") for i in range(n_iters)]
        for k in range(candidatePaths)
    ]
    d_sym_vars = [
        [z3.Int(f"d_{i}_{k}") for i in range(n_iters)] for k in range(candidatePaths)
    ]
    path_prob_sym_vars = [z3.Real(f"path_prob_{i}") for i in range(candidatePaths)]
    probability_vars = [z3.Real(f"probability_{k}") for k in range(candidatePaths)]
    expected_heads = [z3.Int(f"sum_d_heads_{k}") for k in range(candidatePaths)]

    optpath = z3.Optimize()

    # "k" models. One model for each randomized run.
    for k in range(candidatePaths):

        # initalization
        choice_probs = 1
        sum_heads = 0

        # optpath.add(0.0001 <= probability_vars[k])
        # optpath.add(probability_vars[k] < 1.0)

        # Prob value is not concrete, so we get a single number at the end.
        optpath.add(probability_vars[k] == 0.75)

        # "n_iters" coin toss.
        for i in range(n_iters):

            optpath.add(0 <= d_sym_vars[k][i])
            optpath.add(d_sym_vars[k][i] <= 1)

            # Choice Prob ITE.
            optpath.add(
                choice_sym_vars[k][i]
                == z3.If(
                    d_sym_vars[k][i] == 1, probability_vars[k], 1 - probability_vars[k]
                )
            )

            # Path probs is multiplication of choice probs.
            choice_probs = choice_probs * choice_sym_vars[k][i]

            # Heads in this current "n" flips of the iteration.
            # We get one "sum_heads" value of each model in "k" models.
            sum_heads = sum_heads + d_sym_vars[k][i]

        # path_prob = path_prob * choice_prob
        optpath.add(path_prob_sym_vars[k] == choice_probs)

        # E[heads for this run] = path_prob * (sum over "1" in d-vector)
        optpath.add(expected_heads[k] == sum_heads * path_prob_sym_vars[k])

        # Optimization Call.
        # optpath.maximize(expected_heads[k])

    # "d"-vector distinct clause.
    # for i in k-1 : Distinct (d_vec[i], d_vec[i+1])
    # TODO

    # for j in range(candidatePaths - 1):
    #     for iters in range(n_iters):
    #         optpath.add(z3.Distinct(d_sym_vars[j][iters], d_sym_vars[j + 1][iters]))

    # E[heads] = sum(expected_heads[k])
    # Sum over the "k" expected heads terms.
    # TODO

    print(optpath.assertions())

    print(optpath.check())
    print(optpath.model())

    # TODO : Heat Map -> x : different "k" values, y : different "prob" values.
    # TODO : value(x, y) : | n * prob - (value from model i.e sum(expected_heads[k])) |


if __name__ == "__main__":
    generateCandidates(int(sys.argv[1]), int(sys.argv[2]))
