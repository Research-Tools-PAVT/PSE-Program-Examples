# -*- coding: utf-8 -*-

import z3
import os
import sys

"""
Below are a list of constraints that dictate which 
path is taken during actual program execution. 
We process KLEE constraints and simplify them to get these 
constraints. 
"""

# ==== Will be Autogenerated by PyKLEE ====
n_sym, y_sym = z3.Ints("n_sym y_sym")
prob_sym = z3.Real("prob_sym")

path1 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    z3.Not((1 < n_sym)),
]

path2 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    z3.Not((2 < n_sym)),
]

path3 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    z3.Not((3 < n_sym)),
]

path4 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    z3.Not((4 < n_sym)),
]

path5 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    (4 < n_sym),
    z3.Not((5 < n_sym)),
]

path6 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    (4 < n_sym),
    (5 < n_sym),
    z3.Not((6 < n_sym)),
]

path7 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    (4 < n_sym),
    (5 < n_sym),
    (6 < n_sym),
    z3.Not((7 < n_sym)),
]

path8 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    (4 < n_sym),
    (5 < n_sym),
    (6 < n_sym),
    (7 < n_sym),
    z3.Not((8 < n_sym)),
]

path9 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    (4 < n_sym),
    (5 < n_sym),
    (6 < n_sym),
    (7 < n_sym),
    (8 < n_sym),
    (9 < n_sym),
]

path10 = [
    (1 <= n_sym),
    (1 <= y_sym),
    (0.000001 <= prob_sym),
    (prob_sym <= 1),
    (n_sym <= 10),
    (1 < n_sym),
    (2 < n_sym),
    (3 < n_sym),
    (4 < n_sym),
    (5 < n_sym),
    (6 < n_sym),
    (7 < n_sym),
    (8 < n_sym),
    z3.Not((9 < n_sym)),
]


paths = [path1, path2, path3, path4, path5, path6, path7, path8, path9, path10]


# ==== Will be Autogenerated by PyKLEE ====


pwd = os.path.dirname(__file__)
if not os.path.isdir(os.path.join(pwd, "inputs")):
    os.mkdir(os.path.join(pwd, "inputs"))

inputFilePath = os.path.join(pwd, "inputs")


def generateCandidates(k: int):
    for index, path in enumerate(paths):

        print(f"Path {index + 1} : {path}")
        optpath = z3.Optimize()
        optpath.set("timeout", 5000)

        # This will get automated later to parse query
        # and retrieve directly from ProbQueryObject
        # COMMENT : Need to discuss the query constraints for this program.

        # Add the constraints and get candidate model from z3.
        for conds in path:
            optpath.add(conds)

        # COMMENT : Need to frame this optimization properly. How to automate it?
        # optpath.maximize(prob_sym * n_sym * y_sym)

        n = 0
        # TODO : Automate it later get MODELs.
        while optpath.check() == z3.sat and n != k:

            m = optpath.model()
            n += 1

            # Display the current model.
            print(f"\tModel : {n}")
            print("\t\t%s = %s" % (n_sym, m[n_sym]))
            print("\t\t%s = %s" % (y_sym, m[y_sym]))
            value_fraction = m[prob_sym].as_fraction()
            value = float((value_fraction.numerator)) / float(
                (value_fraction.denominator)
            )
            print("\t\t%s = %.10f" % (prob_sym, round(value, 10)))

            # TODO : Automate it later.
            # See Model Values
            with open(
                os.path.join(inputFilePath, f"model_{index}_{n}.txt"), mode="w"
            ) as fileptr:
                fileptr.write(f"{m[n_sym]}\n")
                fileptr.write(f"{m[y_sym]}\n")
                fileptr.write(f"{round(value, 10):.10f}\n")

            # TODO : Automate it later.
            # Added blocking clauses.
            # optpath.add(n_sym != m[n_sym])
            optpath.add(y_sym != m[y_sym])
            optpath.add(prob_sym != m[prob_sym])


if __name__ == "__main__":
    generateCandidates(int(sys.argv[1]))
