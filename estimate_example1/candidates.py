# -*- coding: utf-8 -*-

import z3
import sys
import os

"""
Below are a list of constraints that dictate which 
path is taken during actual program execution. 
We process KLEE constraints and simplify them to get these 
constraints. 
"""

# ==== Will be Autogenerated by PyKLEE ====
a, b, c, d = z3.Ints('a_sym b_sym c_sym d_prob_sym')

klee_assume = z3.And(d >= 0, d <= 500)

cond1 = (a + b > c + d)
notcond1 = z3.Not(a + b > c + d)

cond2 = (a > b)
notcond2 = z3.Not(a > b)

cond3 = (c > d)
notcond3 = z3.Not(c > d)

cond4 = (500 + d < 100 + c)
notcond4 = z3.Not(500 + d < 100 + c)

cond5 = (100 + d < 500 + c)
notcond5 = z3.Not(100 + d < 500 + c)

"""
Paths generated are reported by KLEE. 
"""

path1 = [klee_assume, cond1, cond2, cond4]
path2 = [klee_assume, cond1, cond2, notcond4]
path3 = [klee_assume, cond1, notcond2, cond5]
path4 = [klee_assume, cond1, notcond2, notcond5]
path5 = [klee_assume, notcond1, cond3]
path6 = [klee_assume, notcond1, cond3]

paths = [path1, path2, path3, path4, path5, path6]
# ==== Will be Autogenerated by PyKLEE ====


# ==== Automatically added By Query Parse ====
class ProbQueryObject:
    """ 
    This object is responsible for storing the query proposed by the user
    The user may specify as a comment in the C/C++ code used to symbex via KLEE
    """

    def __init__(self, objective, objectiveType):
        self.objective = objective
        self.type = objectiveType
        self.predicates = []
        self.eval = eval(self.objective)

    def __repr__(self):
        pass

    def __str__(self):
        pass

    def __index__(self, index):
        return self.predicates[index]

    def __getitem__(self, key):
        pass

    def getObjective(self):
        return self.objective

    def typeObjective(self):
        return self.type

    def processObjective(self):
        # process objective & return each predicate
        return self.predicates

# Will automate this more later on.


class Optimizer:
    def __init__(self):
        self.constraints = []
        self.optimizerObj = z3.Optimize()

    def printModel(self):
        pass

    def printConstraints(self):
        pass

    def __str__(self):
        pass

    def __index__(self, index):
        return self.constraints[index]

    def negateModel(self):
        pass

    def checkModel(self):
        pass

    def addConstraint(self, constraint):
        self.constraints.append(constraint)
        return self.optimizerObj.check()


pwd = os.path.dirname(__file__)
inputFilePath = os.path.join(pwd, "inputs")


def generateCandidates(k: int):
    for index, path in enumerate(paths):

        print(f"Path {index + 1} : {path}")
        optpath = z3.Optimize()
        queryObj = ProbQueryObject("a + b + c + d - 100 <= 0", ">=")

        # This will get automated later to parse query
        # and retrieve directly from ProbQueryObject

        # COMMENT : Need to discuss the query constraints for this program.
        optpath.add(a + b + c + d - 1100 <= 0)
        objective = (a + b + c + d - 1100)
        foralls = z3.Sum(a, b, c)

        # Add the constraints and get candidate model from z3.
        for conds in path:
            optpath.add(conds)
            optpath.maximize(foralls)
            if queryObj.type == ">=" or queryObj.type == ">":
                optpath.minimize(objective)
            elif queryObj.type == "<=" or queryObj.type == "<":
                optpath.maximize(objective)
            else:
                # Check what happens in the equality case.
                optpath.minimize(objective)

        n = 0
        # TODO : Automate it later get MODELS.
        while optpath.check() == z3.sat and n != k:

            m = optpath.model()
            n += 1

            # TODO : Automate it later.
            # See Model Values
            with open(os.path.join(inputFilePath, f"model_{index}_{n}.txt"), mode="w") as fileptr:
                fileptr.write(f"{m[a]}\n")
                fileptr.write(f"{m[b]}\n")
                fileptr.write(f"{m[c]}\n")

            print(f"\tModel : {n}")
            print("\t\t%s = %s" % (a, m[a]))
            print("\t\t%s = %s" % (b, m[b]))
            print("\t\t%s = %s" % (c, m[c]))

            # TODO : Automate it later.
            # Added blocking clauses.
            optpath.add(a != m[a])
            optpath.add(b != m[b])
            optpath.add(c != m[c])


if __name__ == "__main__":
    generateCandidates(2)
