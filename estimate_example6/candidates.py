# -*- coding: utf-8 -*-

import z3
import os
import sys

# https://z3prover.github.io/api/html/classz3py_1_1_rat_num_ref.html#a1012d6314d35530c58f9c018269ec867
def num(r):
    """
    Convert from Z3 to python float values.
    """
    return float(r.numerator_as_long()) / float(r.denominator_as_long())


def get_value(r):
    """
    Convert from Z3 to python values.
    """
    if z3.is_int_value(r):
        return r.as_long()
    elif z3.is_algebraic_value(r):
        return round(num(r.approx(15)), 10)
    elif z3.is_rational_value(r):
        return r.as_decimal(20)
    elif r is None:
        None
    else:
        return num(r)


"""
Below are a list of constraints that dictate which 
path is taken during actual program execution. 
We process KLEE constraints and simplify them to get these 
constraints. 
"""

# ==== Will be Autogenerated by PyKLEE ====
prob_sym = z3.Real("prob_sym")
i_sym = z3.Int("i_sym")

path1 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    z3.Not(((i_sym + 1) < 20)),
]

path2 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    z3.Not(((i_sym + 2) < 20)),
]

path3 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    z3.Not(((i_sym + 4) < 20)),
]

path4 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    z3.Not(((i_sym + 3) < 20)),
]

path5 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    z3.Not(((i_sym + 5) < 20)),
]

path6 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    z3.Not(((i_sym + 6) < 20)),
]

path7 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    z3.Not(((i_sym + 7) < 20)),
]

path8 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    ((i_sym + 6) < 20),
    z3.Not(((i_sym + 8) < 20)),
]

path9 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    z3.Not(((i_sym + 9) < 20)),
]

path10 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    ((i_sym + 6) < 20),
    ((i_sym + 8) < 20),
    z3.Not(((i_sym + 10) < 20)),
]

path11 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    ((i_sym + 9) < 20),
    z3.Not(((i_sym + 11) < 20)),
]

path12 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    ((i_sym + 6) < 20),
    ((i_sym + 8) < 20),
    ((i_sym + 10) < 20),
    z3.Not(((i_sym + 12) < 20)),
]

path13 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    ((i_sym + 9) < 20),
    ((i_sym + 11) < 20),
    z3.Not(((i_sym + 13) < 20)),
]

path14 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    ((i_sym + 6) < 20),
    ((i_sym + 8) < 20),
    ((i_sym + 10) < 20),
    ((i_sym + 12) < 20),
    z3.Not(((i_sym + 14) < 20)),
]

path15 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    ((i_sym + 9) < 20),
    ((i_sym + 11) < 20),
    ((i_sym + 13) < 20),
    z3.Not(((i_sym + 15) < 20)),
]

path16 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    ((i_sym + 6) < 20),
    ((i_sym + 8) < 20),
    ((i_sym + 10) < 20),
    ((i_sym + 12) < 20),
    ((i_sym + 14) < 20),
    ((i_sym + 16) < 20),
]

path17 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    z3.Not((i_sym < 20)),
    ((i_sym + 2) < 20),
    ((i_sym + 4) < 20),
    ((i_sym + 6) < 20),
    ((i_sym + 8) < 20),
    ((i_sym + 10) < 20),
    ((i_sym + 12) < 20),
    ((i_sym + 14) < 20),
    z3.Not(((i_sym + 16) < 20)),
]

path18 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    ((i_sym + 9) < 20),
    ((i_sym + 11) < 20),
    ((i_sym + 13) < 20),
    ((i_sym + 15) < 20),
    z3.Not(((i_sym + 17) < 20)),
]

path19 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    z3.Not((i_sym % 2) == 0),
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    ((i_sym + 9) < 20),
    ((i_sym + 11) < 20),
    ((i_sym + 13) < 20),
    ((i_sym + 15) < 20),
    ((i_sym + 17) < 20),
]

path20 = [
    (0.00001 <= prob_sym),
    (1 <= i_sym),
    (prob_sym <= 1),
    (i_sym <= 20),
    (i_sym < 20),
    (i_sym % 2) == 0,
    ((i_sym + 1) < 20),
    ((i_sym + 3) < 20),
    ((i_sym + 5) < 20),
    ((i_sym + 7) < 20),
    ((i_sym + 9) < 20),
    ((i_sym + 11) < 20),
    ((i_sym + 13) < 20),
    ((i_sym + 15) < 20),
    ((i_sym + 17) < 20),
]


paths = [
    path1,
    path2,
    path3,
    path4,
    path5,
    path6,
    path7,
    path8,
    path9,
    path10,
    path11,
    path12,
    path13,
    path14,
    path15,
    path16,
    path17,
    path18,
    path19,
    path20,
]

# prob == 0.5 during SE.

# OPTIMIZE_ARR = [
#     1 * y_sym - prob_sym * n_sym * y_sym,  # d == 1
#     2 * y_sym - prob_sym * n_sym * y_sym,  # d == 1
#     3 * y_sym - prob_sym * n_sym * y_sym,  # d == 0
#     3 * y_sym - prob_sym * n_sym * y_sym,  # d == 0
#     3 * y_sym - prob_sym * n_sym * y_sym,  # d == 0
#     3 * y_sym - prob_sym * n_sym * y_sym,  # d == 1
#     4 * y_sym - prob_sym * n_sym * y_sym,  # d == 0
#     4 * y_sym - prob_sym * n_sym * y_sym,  # d == 1
#     5 * y_sym - prob_sym * n_sym * y_sym,  # d == 1
#     6 * y_sym - prob_sym * n_sym * y_sym,  # d == 0
# ]

# ==== Will be Autogenerated by PyKLEE ====


pwd = os.path.dirname(__file__)
if not os.path.isdir(os.path.join(pwd, "inputs")):
    os.mkdir(os.path.join(pwd, "inputs"))

inputFilePath = os.path.join(pwd, "inputs")


def generateCandidates(k: int):
    for index, path in enumerate(paths):

        print(f"Path {index + 1} : {path}")
        optpath = z3.Optimize()
        optpath.set("timeout", 5000)
        z3.set_option(
            precision=15,
            rational_to_decimal=True,
            max_args=10000000,
            max_lines=1000000,
            max_depth=10000000,
            max_visited=1000000,
        )
        # z3.set_option(precision=30)

        # This will get automated later to parse query
        # and retrieve directly from ProbQueryObject
        # COMMENT : Need to discuss the query constraints for this program.

        # Add the constraints and get candidate model from z3.
        for conds in path:
            optpath.add(conds)

        # COMMENT : Need to frame this optimization properly. How to automate it?
        # optpath.minimize(OPTIMIZE_ARR[index])

        n = 0
        # TODO : Automate it later get MODELs.
        # (optpath.check() == z3.sat or optpath.check == z3.unknown)
        while optpath.check() != z3.unsat and n != k:

            print(optpath.check())
            m = optpath.model()
            # print(m)
            print(f"\tModel : {n + 1}")
            print("\t\t%s = %s" % (i_sym, get_value(m[i_sym])))
            print("\t\t%s = %s" % (prob_sym, get_value(m[prob_sym])))

            with open(
                os.path.join(inputFilePath, f"model_{index}_{n}.txt"), mode="w"
            ) as fileptr:
                fileptr.write(f"{get_value(m[i_sym])}\n")
                fileptr.write(f"{get_value(m[prob_sym])}\n")

            n += 1

            # TODO : Automate it later.
            # Added blocking clauses.
            # optpath.add(n_sym != m[n_sym])
            # optpath.add(i_sym > m[i_sym] + 2)
            optpath.add(prob_sym != m[prob_sym])


if __name__ == "__main__":
    generateCandidates(int(sys.argv[1]))
